(() => {
  // src/apiCaller.js
  var fetchApiData = (apiUrl) => {
    return new Promise((resolve, reject) => {
      fetch(apiUrl).then((response) => {
        if (!response.ok) {
          throw new Error(`HTTP error! Status: ${response.status}`);
        }
        return response.json();
      }).then((data) => {
        resolve(data);
      }).catch((error) => {
        reject(error);
      });
    });
  };

  // src/prefixes.js
  var prefixes = [" ", "sm:", "md:", "lg:", "xl:", "xxl:"];
  var getPrefixes = async (fromDB = false) => {
    if (fromDB) {
      try {
        return await fetchApiData("your-api-endpoint");
      } catch (error) {
        console.error("Error:", error);
        return [];
      }
    } else {
      return prefixes;
    }
  };

  // src/suggestions.js
  var suggestions = [
    "white",
    "yellow",
    "blue",
    "red",
    "green",
    "black",
    "brown",
    "azure",
    "ivory",
    "teal"
  ];
  var getSuggestions = async (fromDB = false) => {
    if (fromDB) {
      try {
        return await fetchApiData("your-api-endpoint");
      } catch (error) {
        console.error("Error:", error);
        return [];
      }
    } else {
      return suggestions;
    }
  };

  // src/utilities.js
  var parseValue = (v) => v.endsWith("px") ? parseInt(v.slice(0, -2), 10) : 0;
  var clamp = (min, value, max) => Math.min(Math.max(min, value), max);
  var findIndexOfCurrentWord = (textarea) => {
    const currentValue = textarea.value;
    const cursorPos = textarea.selectionStart;
    let startIndex = cursorPos - 1;
    while (startIndex >= 0 && !/\s/.test(currentValue[startIndex])) {
      startIndex--;
    }
    return startIndex;
  };
  var replaceCurrentWord = (textarea, newWord, prefixes2) => {
    const currentValue = textarea.value;
    const cursorPos = textarea.selectionStart;
    const startIndex = findIndexOfCurrentWord(textarea);
    let prefix = "";
    for (const pref of prefixes2) {
      const potentialStartIndex = cursorPos - pref.length;
      if (potentialStartIndex >= 0 && currentValue.substring(potentialStartIndex, cursorPos) === pref) {
        prefix = pref;
        break;
      }
    }
    const newValue = currentValue.substring(0, startIndex + 1) + prefix + newWord + currentValue.substring(cursorPos);
    textarea.value = newValue;
    textarea.focus();
    textarea.selectionStart = textarea.selectionEnd = startIndex + 1 + prefix.length + newWord.length;
  };

  // src/main.js
  var __prefixes = [];
  var __suggestions = [];
  document.addEventListener("DOMContentLoaded", async () => {
    __prefixes = await getPrefixes();
    __suggestions = await getSuggestions();
    console.log(__prefixes);
    console.log(__suggestions);
    const containerEle = document.getElementById("container");
    const textarea = document.getElementById("textarea");
    const mirroredEle = document.createElement("div");
    mirroredEle.textContent = textarea.value;
    mirroredEle.classList.add("container__mirror");
    containerEle.prepend(mirroredEle);
    const suggestionsEle = document.createElement("div");
    suggestionsEle.classList.add("container__suggestions");
    containerEle.appendChild(suggestionsEle);
    const textareaStyles = window.getComputedStyle(textarea);
    [
      "border",
      "boxSizing",
      "fontFamily",
      "fontSize",
      "fontWeight",
      "letterSpacing",
      "lineHeight",
      "padding",
      "textDecoration",
      "textIndent",
      "textTransform",
      "whiteSpace",
      "wordSpacing",
      "wordWrap"
    ].forEach((property) => {
      mirroredEle.style[property] = textareaStyles[property];
    });
    mirroredEle.style.borderColor = "transparent";
    const borderWidth = parseValue(textareaStyles.borderWidth);
    const ro = new ResizeObserver(() => {
      mirroredEle.style.width = `${textarea.clientWidth + 2 * borderWidth}px`;
      mirroredEle.style.height = `${textarea.clientHeight + 2 * borderWidth}px`;
    });
    ro.observe(textarea);
    textarea.addEventListener("scroll", () => {
      mirroredEle.scrollTop = textarea.scrollTop;
    });
    textarea.addEventListener("input", () => {
      const currentValue = textarea.value;
      const cursorPos = textarea.selectionStart;
      const startIndex = findIndexOfCurrentWord(textarea);
      const currentWord = currentValue.substring(startIndex + 1, cursorPos);
      if (currentWord === "") {
        suggestionsEle.style.display = "none";
        return;
      }
      let prefixMatched = false;
      __prefixes.forEach((prefix) => {
        if (currentWord.startsWith(prefix)) {
          prefixMatched = true;
        }
      });
      let matches = [];
      if (prefixMatched) {
        matches = __suggestions;
      } else {
        matches = __suggestions.filter(
          (suggestion) => suggestion.indexOf(currentWord) > -1
        );
      }
      if (matches.length === 0) {
        suggestionsEle.style.display = "none";
        return;
      }
      const textBeforeCursor = currentValue.substring(0, cursorPos);
      const textAfterCursor = currentValue.substring(cursorPos);
      const pre = document.createTextNode(textBeforeCursor);
      const post = document.createTextNode(textAfterCursor);
      const caretEle = document.createElement("span");
      caretEle.innerHTML = "&nbsp;";
      mirroredEle.innerHTML = "";
      mirroredEle.append(pre, caretEle, post);
      const rect = caretEle.getBoundingClientRect();
      suggestionsEle.style.top = `${rect.top + rect.height}px`;
      suggestionsEle.style.left = `${rect.left}px`;
      suggestionsEle.innerHTML = "";
      matches.forEach((match) => {
        const option = document.createElement("div");
        option.classList.add("container__suggestion");
        const matchIndex = match.toLowerCase().indexOf(currentWord.toLowerCase());
        if (matchIndex >= 0) {
          const beforeMatch = match.substring(0, matchIndex);
          option.appendChild(document.createTextNode(beforeMatch));
          const matchedText = match.substring(
            matchIndex,
            matchIndex + currentWord.length
          );
          const highlightSpan = document.createElement("span");
          highlightSpan.classList.add("highlight");
          highlightSpan.textContent = matchedText;
          option.appendChild(highlightSpan);
          const afterMatch = match.substring(
            matchIndex + currentWord.length
          );
          option.appendChild(document.createTextNode(afterMatch));
        } else {
          option.textContent = match;
        }
        option.addEventListener("click", function() {
          replaceCurrentWord(textarea, match, __prefixes);
          suggestionsEle.style.display = "none";
        });
        suggestionsEle.appendChild(option);
      });
      suggestionsEle.style.display = "block";
    });
    let currentSuggestionIndex = -1;
    textarea.addEventListener("keydown", (e) => {
      if (![
        "ArrowDown",
        "ArrowUp",
        "Enter",
        "Escape",
        "Tab",
        "ArrowRight"
      ].includes(e.key)) {
        return;
      }
      const suggestionsElements = suggestionsEle.querySelectorAll(
        ".container__suggestion"
      );
      const numSuggestions = suggestionsElements.length;
      if (numSuggestions === 0 || suggestionsEle.style.display === "none") {
        return;
      }
      e.preventDefault();
      switch (e.key) {
        case "ArrowDown":
          suggestionsElements[clamp(0, currentSuggestionIndex, numSuggestions - 1)].classList.remove("container__suggestion--focused");
          currentSuggestionIndex = clamp(
            0,
            currentSuggestionIndex + 1,
            numSuggestions - 1
          );
          suggestionsElements[currentSuggestionIndex].classList.add(
            "container__suggestion--focused"
          );
          break;
        case "ArrowUp":
          suggestionsElements[clamp(0, currentSuggestionIndex, numSuggestions - 1)].classList.remove("container__suggestion--focused");
          currentSuggestionIndex = clamp(
            0,
            currentSuggestionIndex - 1,
            numSuggestions - 1
          );
          suggestionsElements[currentSuggestionIndex].classList.add(
            "container__suggestion--focused"
          );
          break;
        case "Enter":
        case "Tab":
        case "ArrowRight":
          if (currentSuggestionIndex >= 0 && currentSuggestionIndex < numSuggestions) {
            replaceCurrentWord(
              textarea,
              suggestionsElements[currentSuggestionIndex].innerText,
              __prefixes
            );
            suggestionsEle.style.display = "none";
            if (e.key !== "Enter") {
              textarea.focus();
            }
          }
          break;
        case "Escape":
          suggestionsEle.style.display = "none";
          break;
      }
    });
  });
})();
